use axum::{
    Router,
    routing::{ get, post, delete, put, patch, head},
    extract::State,
    response::IntoResponse,
    http::StatusCode,
    Json,
};
use tonic::transport::Channel;
use serde::{Deserialize, Serialize};
use crate::generated::{{ service.name | snake_case }}::{{ service.name | snake_case }}_client::{{ service.name }}Client;
use crate::generated::{{ service.name | snake_case }}::{ {% for e in service.endpoints %}{{ e.request.type }}, {{
e.response.type }}{% if not loop.last %}, {% endif %}{% endfor %} };

use crate::http::error::map_grpc_error;

{% for e in service.endpoints %}
#[derive(Debug, Deserialize, Serialize)]
struct Http{{ e.request.type }} {
    {% for field in e.request.fields %}
    pub {{ field.name }}: {{ field.type }},
    {% endfor %}
}

#[derive(Debug, Deserialize, Serialize)]
struct Http{{ e.response.type }} {
    {% for field in e.response.fields %}
    pub {{ field.name }}: {{ field.type }},
    {% endfor %}
}

{% endfor %}

#[derive(Clone)]
pub struct AppState {
    pub client: {{ service.name }}Client<Channel>,
}

pub async fn routes() -> Router {
    let channel = Channel::from_shared("{{ service.url}}".to_string())
        .unwrap()
        .connect()
        .await
        .unwrap();

    let client = {{ service.name }}Client::new(channel);

    let state = AppState { client };

    Router::new()
    {% for e in service.endpoints %}
        .route("{{ e.path }}", {{ e.method | lower }}({{ e.rpc | snake_case }}))
    {% endfor %}
        .with_state(state)
}

{% for e in service.endpoints %}
async fn {{ e.rpc | snake_case }}(
    State(mut state): State<AppState>,
    Json(input): Json<Http{{ e.request.type }}>,
) -> impl IntoResponse {
    let request = tonic::Request::new({{ e.request.type }} {
        {% for field in e.request.fields %}
        {{ field.name }}: input.{{ field.name }},
        {% endfor %}
    });

    let response = state.client.{{ e.rpc | snake_case }}(request).await;

    match response {
        Ok(res) => {
            let response_body = res.into_inner();

            let http_response = Http{{ e.response.type }} {
                {% for field in e.response.fields %}
                {{ field.name }}: response_body.{{ field.name }},
                {% endfor %}
            };

            (StatusCode::OK, Json(http_response)).into_response()
        }

        Err(e) => {
            eprintln!("Error calling {}: {}", "{{ service.name }}::{{ e.rpc | snake_case }}", e);
            map_grpc_error(e).into_response()
        }
    }
}
{% endfor %}